\chapter{Getting Started in BASIC}
\label{cha:basic-getting-started}

It is possible to code on the MEGA65 in many languages,
however most people start with BASIC.  That makes sense,
because BASIC stands for Beginner's All-purpose Symbolic
Instruction Code: It was made for people like you to get
started with in the world of coding!

A few short words before we dive in: BASIC is a programming
language, and like spoken language it has conventions, grammar
and vocabulary.  Fortunately, it is much quicker and easier
to learn than our complex human languages. But if you pay
attention, you might notice some of these structures, and that
can help you along your path in the world of coding.

If you haven't already read \bookvref{cha:getting-started},
it might be a good idea to do so. This will help you be able to
more confidently interact with the MEGA65 computer.

It's also great to remember that if you really confuse the MEGA65,
you can always get back to the READY. prompt by just pressing the
reset button on the left-hand side of the keyboard, or if that
doesn't help, then by turning it off
and on again using the power switch on the left-hand side of the keyboard.
You don't have to worry about shutting the computer
down properly or any of that nonsense.  The only thing to remember
is that if you had any unsaved work, it will be lost when you turn
the computer off and on again or press the reset button.

Finally, if you don't understand all of the descriptions and information
with an example -- don't worry! We have provided as much information
as we can, so that it is there in case you have questions, encounter problems are
just curious to discover more.  Feel free to skip ahead to the examples
and try things out, and then you can go back and re-read it when you are motivated
to find something out, or help you work though a problem.  And if you don't find
the answer to your problem, send us a message!  There are support forums for the
MEGA65 at \url{https://mega65.net}, and you can
report problems with this guide at:

\url{https://github.com/mega65/mega65-user-guide}

We hope you have as much fun learning to programme the MEGA65 as
we have had making it!

\section{Your first BASIC programmes}

The MEGA65 was designed to be programmed! When you turn it on,
it takes a couple of seconds to get its house in order, and then
it quickly shows you a ``READY.'' prompt and flashing block called
the cursor.  When the cursor is blinking, it tells you that the
computer is waiting for input.  The ``READY.'' message tells you
that the BASIC programming language is running and ready for you to
start programming.  You don't even need to load any programmes --
you can just get started.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following element
Try typing the following into the computer and see what happens:

\begin{screenoutput}
HELLO COMPUTER
\end{screenoutput}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot

To do this, just type the letters as you see them above.  The computer
will already be in upper-case mode, so you don't need to hold the \specialkey{SHIFT}
or \specialkey{CAPS\\LOCK} key down.  When you have typed ``HELLO COMPUTER'' press
  the \specialkey{RETURN} key.  This tells the computer you want it to accept the
  line of input you have typed.  When you do this, you should see a message something
  like the following:

\screenshotwrap{images/syntax-error.png}

  If you saw a \screentextwide{SYNTAX ERROR} message something like that one, then congratulations:
  You have succeeded in communicating with the computer!\index{Errors!Syntax}\index{SYNTAX ERROR}
  Error messages sound much nastier than they are.  The MEGA65 uses them, especially
  the syntax error to tell you when it is having trouble understanding what you have
  typed, or what you have put in a programme.  They are nothing to be afraid of, and
  experienced programmers get them all the time.

  In this case, the computer was confused because it doesn't understand the word
  ``hello'' or the word ``computer''.  That is, it didn't know what you wanted it to
  do.  In this regard, computers are quite stupid. They know only a few words, and
  aren't particularly imaginative about how they interpret them.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot

So let's try that again in a way that the computer will understand.  Try typing
  the following in.  You can just type it right away. It doesn't matter that the
  syntax error message can still be seen on the screen.  The computer has already
  forgotten about that by the time it told you \screentextwide{READY.} again.

\begin{screenoutput}
PRINT "HELLO COMPUTER"
\end{screenoutput}

Again, make sure you don't use shift or shift-lock while typing it in.  The symbols around
the words \screentextwide{HELLO COMPUTER} are double-quotes.  If you are used to an Australian or American
keyboard, you might discover that they double-quote key is in a rather different place to
where you are used to:  Double-quotes can be typed on the MEGA65 by holding down the
\specialkey{SHIFT} key, and then pressing 2.  Don't forget to press the \specialkey{RETURN}
key when you are done, so that the computer knows you want it to do something with your input.

If you make a mistake while typing, you can use the \specialkey{INST\\DEL} to rub out the mistake
and fix it up.  You can also use the cursor keys to move back and forth on the line while
you edit the line you are typing, but there is a bit of a trick if you have already typed
a double-quote: If you try to use the cursor keys, it will print a funny reversed symbol
instead of moving the cursor.  This is because the computer thinks you want to record
moving the cursor in the text itself, which can be really useful and fun, and which you can
read more about in \bookvref{cha:getting-started}. But for now, if you
make a mistake just press the \specialkey{RETURN} key and type the messed up line again.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
Hopefully now you will see something like the following:

\screenshotwrap{images/print-hello-computer.png}

  This time no new \screentextwide{SYNTAX ERROR} message should appear. But if some kind
  of error message has appeared, just try typing in the command again, after
  taking a close look to work out where the mistake might be.

  Instead of an error, we should see \screentextwide{HELLO COMPUTER} repeated underneath
  the line you typed in.  The reason this happened is that the computer
  does understand the word \screentextwide{PRINT}.  It knows that whatever comes after
  the word \screentextwide{PRINT} should be printed to the screen.  We had to put \screentextwide{HELLO
  COMPUTER} inside double-quotes to tell the computer that we want it to be
  printed literally.

  If we hadn't put the double-quotes in, the computer would have thought
  that \screentextwide{HELLO COMPUTER} was the name of a stored piece of information.
  But because we haven't stored any piece of information in such a place,
  the computer will have zero there, so the computer will print the number
  zero. If the computer prints zero or some other number when
  you expected a message of some sort, this can be the reason.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
  You can try it, if you like, and you should see something like the following:

  \screenshotwrap{images/print-hello-computer-no-quotes.png}

  In the above examples we typed commands in directly, and the computer executed
  them immediately after you pressed the \specialkey{RETURN} key.  This is why
  typing commands in this way is often called {\em direct mode} or {\em immediate mode}.

  But we can also tell the computer to remember a list of commands to execute one
  after the other.   This is done using the rather unimaginatively named {\em non-direct mode}.
  To use non-direct mode, we just put a number between 0 and 63999 at the start of
  the command.  The computer will then remember that command.  Unlike when we executed
  a direct-mode command, the computer doesn't print \screentextwide{READY.} again. Instead the cursor
  just reappears on the next line, ready for us to type in more commands.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
  Let's try that out with a simple little programme.  Type in the following three lines of
  input:

\begin{screenoutput}
1 FOR I = 1 TO 10 STEP 1
2 PRINT I
3 NEXT I
\end{screenoutput}
\index{FOR}
\index{BASIC 65 Commands!FOR}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
When you have done this, the screen should show something like this:

\screenshotwrap{images/first-steps-for-loop-programme-1.png}

If it doesn't you
can try again. Don't forget, if you feel that the computer is getting all muddled up,
you can just press the reset button or flip the power switch off and on on the left side of the
computer to reboot it. This only takes a couple of seconds, and doesn't hurt the MEGA65
in anyway.

We have told the computer to remember three commands, that is, \screentextwide{FOR I = 1 TO 10 STEP 1},
\screentextwide{PRINT I}
and \screentextwide{NEXT I}.  We have also told the computer which order we would like to run them in: The
computer will start with the command with the lowest number, and execute each command that
has the next higher number in turn, until it reaches the end of the list.  So it's a bit like
a reminder list for the computer. This is what we call a programme, a bit like the programme at
a concert or the theatre, it tells us what is coming up, and in what order.
So let's tell the computer to execute this programme.

But first, let's try to guess what will happen.  Let's start with the middle command, \screentextwide{PRINT I}.
We've seen the \screentextwide{PRINT} command, and we know it tells the computer to print things to the screen.
The thing it will try to print is \screentextwide{I}.  Just like before, because there are no double-quotes
around the \screentextwide{I}, it will try to print a piece of stored information.  The piece of information
it will try to print will be the piece associated with the thing \screentextwide{I}.

When we give a piece of
information like this a name, we call it a {\em variable}\index{variable}.  They are called
variables because they can vary.  That is, we can replace the piece of information associated
with the variable called I with another piece of information.  The old piece will be forgotten
as a result.  So if we gave a command like \screentextwide{LET I = 3}, this would replace whatever was stored
in the variable called \screentextwide{I} with the number 3.

Back to our programme, we now know that the 2\textsuperscript{nd} command will try to print the piece of information
stored in the variable \screentextwide{I}.  So lets look at the first command: \screentextwide{FOR I = 1 TO 10 STEP 1}.  Although
we haven't seen the \screentextwide{FOR} command before, we can take a bit of a guess at how it works. It looks like
it is going to put something into the variable \screentextwide{I}.  That something seems to have something to do
with the range of number 1 through 10, and a step or interval of 1.  What do you think it will do?

If you guessed
that it will put the values 1, 2, 3, 4, 5, 6, 7, 8, 9 and then 10 into the variable \screentextwide{I}, then you
can give yourself a pat on the back, because that's exactly what it does.  It also helps us to
understand the 3\textsuperscript{rd} command, \screentextwide{NEXT I}: That command tells the computer to put the next value into
the variable \screentextwide{I}.  And here is a little bit of magic: When the computer does that, it goes back
up the list of commands, and continues again from the command after the \screentextwide{FOR} command.

So lets pull that together: When the computer executes the first command, it discovers that it has
to put 10 different values into the variable \screentextwide{I}. It starts by putting the first value in there, which
in this case will be the number 1.
The computer then continues to the second command, which tells the computer to print the piece of
information that is currently stored in the variable called \screentextwide{I}. That will be the number 1, since
that was the last thing the computer was told to put there.  Then the computer proceeds to the
third command, which tells it that it is time to put the next value into the variable \screentextwide{I}.  So the
computer will throw away the number 1 that is currently in the variable \screentextwide{I}, and put the number 2 in
there, since that is the next number in the list.  It will then continue from the 2\textsuperscript{nd} command,
which will cause the computer to print out the contents of the variable \screentextwide{I} again.  Except that this
time \screentextwide{I} has had the number 2 stored in it most recently, so the computer will print the number 2.
This process will repeat, until the computer has printed all ten values that the \screentextwide{FOR} command
indicated it to do.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
To see this in action, we need to tell the computer to execute the programme of commands we typed in.
We do this by using the \screentextwide{RUN} command. Because we want it to run the programme immediately, we
should use immediate mode (remember, this is another name for direct mode).
So just type in the word \screentextwide{RUN} and press the \specialkey{RETURN} key.  You should then see a display
that looks something like the following:

\screenshotwrap{images/first-steps-for-loop-programme-1-running.png}

  You might notice a couple of things here:

  First, the computer has told us it is \screentextwide{READY.} again
  as soon as it finished running the programme. This just makes it easier for us to know when we
  can start giving commands to the computer again.

  Second, when the computer got to the bottom of the screen
  it automatically scrolled the display up to make space.  This is quite normal.  What is important
  to remember, is that the computer forgets everything that scrolls off the top.  The only exception
  is if you have told the computer to remember a command by putting a number in front of it.  So
  our programme is quite safe for now. We can see that this is the case by typing the \screentextwide{RUN} command a
  couple more times: The programme listing will have scrolled off the top of the screen, but we can
  still RUN the programme, because the computer has remembered it.  Give it a try!
  Did it work?

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
  If you wish to see the programme of remembered commands, you can use the \screentextwide{LIST}\index{LIST}\index{BASIC 65 Commands!LIST}
  command.  This commands causes the computer to display the remembered programme of commands to the screen, like in the display here.
  If you would like to replace any of the commands in the programme, you can type a new line that has the same number as the one you
  wish to change.

\screenshotwrap{images/first-steps-for-loop-programme-1-listing.png}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
  For example, to print the results all on one line, we could modify the second line of the programme to \screentextwide{PRINT I;} by
  typing the following line of input and pressing the \specialkey{RETURN} key:



\begin{screenoutput}
2 PRINT I;
\end{screenoutput}

\index{PRINT}
\index{BASIC 65 Commands!PRINT}
%\end{tcolorbox}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot

You can make sure that the change has been remembered by running the \screentextwide{LIST} command again, as we can see here.
You can then use the \screentextwide{RUN} command to run the modified
programme, like this:

\screenshotwrap{images/first-steps-for-loop-programme-1-modified.png}

It is quite easy to modify your programmes in this way.  As you become more comfortable with the process, there are two
additional helpful tricks:

First, you can give the \screentextwide{LIST} command the number of a command, or line as they are referred to, and it will display only
that line of the programme.  Alternatively, you can give a range separated by a minus sign to display only a section of the programme,
e.g., \screentextwide{LIST 1 - 2} to list the first two lines of our programme.

Second, you can use the cursor keys to move the cursor to a line which has already been remembered and is displayed on the screen. If you
modify what you see on the screen, and then press the \specialkey{RETURN} key while the cursor is on that line, the BASIC interpreter will
read in the modified line and replace the old version of it.  It is important to note that if you modify multiple lines of the programme
at the same time, you must press the \specialkey{RETURN} key on each line that has been modified. It is good practice to check that the
programme has been correctly modified. Use the \specialkey{LIST}\index{LIST}\index{BASIC 65 Commands!LIST} command again to achieve this.


  \subsubsection{Exercises to try}

  {\bf 1. Can you make it count to a higher or lower number?}

  At the moment it counts from 1 to 10.  Can you change it to count to 20 instead?  Or to count from 3 to 17?
  Or how about from 14.5 to 21.5? What do you think you would need to reverse the order in which it counts?

  {\em Clue:} You will need to modify the \screentextwide{FOR} command.

  {\bf 2. Can you change the counting step?}

  At the moment it counts by ones, i.e., each number is one more than the last.  Can you change it to count by twos
  instead? Or by halves, so that it counts 1, 1.5, 2, 2.5, 3, \ldots?

  {\em Clue:} You will need to modify the \screentextwide{STEP} clause
  of the \screentextwide{FOR} command.\index{STEP}\index{BASIC 65 Commands!STEP}


  {\bf 3. Can you make it print out one of the times tables?}

  At the moment it prints the answers to the 1 times tables, because it counts by ones.
  Can you make it count by threes, and show the three times tables?

  {\em Clue:} You will need to modify the \screentextwide{FOR} command.

  {\bf 4. Can you make it print out the times tables from 1$\times$1 to 10$\times$10?}

  {\em Clue:} You might like to use ; on the end of \screentextwide{PRINT} command, so that you can have
  more than one entry per line on the screen.\\
  {\em Clue:} The \screentextwide{PRINT} command without any argument will just advance to the start of the next line.\\
  {\em Clue:} You might need to have multiple \screentextwide{FOR} loops, one inside the other.

\section{First steps with text and numbers}

In the last section we started to use both numbers and text.  Text on computers is made by stringing individual letters
and other symbols together.  For this reason they are called {\em strings}.  We also call the individual letters and
symbols {\em characters}.  The name character comes from the printing industry where each of the symbols that can be
printed on a page. For computers, it has much the same meaning, and the set of characters that a computer can display
is rather unimaginatively called a {\em character set}.\index{character}\index{character set}\index{string}.

When the MEGA65 expects some for of input, it is typically looking for one of four things:

\begin{enumerate}
\item {\em a keyword} like \screentextwide{PRINT} or \screentextwide{STEP}, which are words that have a special meaning to the computer;
\item {\em a variable name} like \screentextwide{I} or \screentextwide{A\$} that it will then use to either store or retrieve a piece of information;
\item {\em a number} like \screentextwide{42} or \screentextwide{-30.3137}; or
\item {\em a string} like \screentextwide{"HELLO COMPUTER"} or \screentextwide{"23 KILOMETRES"}.
\end{enumerate}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
Sometimes you have a choice of which sort of thing you can provide, while other times you have less choice. What
sort of thing the computer will accept depends on what you are doing at the time.  For example, in the previous
section we discovered that when the computer tells us that it is \screentextwide{READY}, that we can give it
a keyword or a number.  Do you think that the computer will accept all four kinds of thing when it says
\screentextwide{READY.}?  We already know that keywords and numbers and keywords can be entered, but what about
variable names or strings?  Let's try typing in a variable name, say \screentextwide{N}, and pressing the \specialkey{RETURN} key,
and see what happens.  And then lets try with a string, say \screentextwide{"THIS IS A STRING"}.

\screenshotwrap{images/typing-variable-name-or-string}

You should get a syntax error each time, telling you that the computer doesn't understand the input you have given it.
Let's start with when you typed the variable: If you just tell the computer the name of a stored piece of information,
it doesn't have the foggiest idea what you are wanting it to do.  It's the same when you give it a piece of information,
like a string, without telling the computer what to do with it.

But as we discovered in the last section, we can tell the computer that we want to see the piece of information that is
stored in a variable using the \screentextwide{PRINT} command.  So we could instead type in \screentextwide{PRINT N}, and
the computer would know what to do, and will print the piece of information stored in the variable called \screentextwide{N}.

In fact, using the \screentextwide{PRINT} command is so common, that programmers got annoying having to type in the \screentextwide{PRINT}
command all the time, that they made a short cut: If you type a question mark character, i.e., a \screentextwide{?}, the computer
knows that you mean \screentextwide{PRINT}.  So for example if you type \screentextwide{? N}, it will do the same as typing
\screentextwide{PRINT N}.  Of course, you have to press the \specialkey{RETURN} key after each command to tell the computer
you want it to process what you typed.  From here on, we will assume that you can remember to do that, without being reminded.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
The \screentextwide{?} shortcut also works if you are telling the computer to remember a command as part of a programme.
So if you type \screentextwide{1 ? N}, and then \screentextwide{LIST}, you will see \screentextwide{1 PRINT N}, as we can see
in the following screen-shot:

\screenshotwrap{images/print-question-mark}

Like we saw in the last section, the variable \screentextwide{N} has not had a value stored in it, so when the computer looks for
what is there, it finds nothing.  Because \screentextwide{N} is a {\em numeric variable}\index{variable!numeric}, when there is
nothing there, this means zero.  If it was a {\em string variable}\index{variable!string}, then it would have found literally nothing.
We can try that, but first we have to explain how we tell the computer we are talking about a string variable.  We do that by
putting a dollar sign character, i.e., a \screentextwide{\$}, on the end of the variable name. So if we put a \screentextwide{\$} on
the end of the variable name \screentextwide{N}, it will refer to a string variable called \screentextwide{N\$}.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
We can experiment with these variables by using the hopefully now familiar
\screentextwide{PRINT} command (or the \screentextwide{?} shortcut)
to see what is in the variables. But we need a convenient way to put
values into them.  Fortunately we aren't the first people to want to
put values into variables, and so the
\screentextwide{LET}\index{LET}\index{BASIC 65 Commands!LET} exists.
The \screentextwide{LET} command is used to put a value into a
variable.  For example, we can tell the computer:

\begin{screenoutput}
  LET N = 5.3
\end{screenoutput}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
This tells the computer to put the value 5.3 into the variable
\screentextwide{N}.  We can then use the \screentextwide{PRINT}
command to check that it worked.  Similarly, we can put a value into
the variable \screentextwide{N\$} with something like:

\begin{screenoutput}
  LET N$ = "THE KING OF THE POTATO PEOPLE"
\end{screenoutput}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
If we try those, we will see something like the following:

\screenshotwrap{images/let-command-examples}

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
We mentioned just before that \screentextwide{N} is a numeric
variable and that \screentextwide{N\$} is a string variable. This
means that we can only put numbers into \screentextwide{N} and
strings into \screentextwide{N\$}.  If we try to put the wrong kind
of information into a variable, the computer will tell us that we have
mis-matched the kind of information with the place we are trying to
put it by giving us a \screentextwide{TYPE MISMATCH
  ERROR}\index{Errors!Type mismatch}\index{Type mismatch error} like
this:

\screenshotwrap{images/type-mismatch-errors}

This leads us to a rather important point: \screentextwide{N} and
\screentextwide{N\$} are separate variables, even though they have
similar names.  This applies to all possible variable names: If the
variable name has a \screentextwide{\$} character on the end, it
means it is a string variable quite separate from the similarly named
numeric variable.  To use a bit of jargon, this means that each {\em type}
of variable has their own separate {\em name
  spaces}\index{name spaces}.

(There are also four other variable name
spaces that we haven't talked about yet: integer variables, identified
by having a \screentextwide{\%} character at the end of their name,
e.g., \screentextwide{N\%}, and arrays of numeric, string or integer
variables. But don't worry about those for now.
We'll talk about those a bit later on.)

So far we have only given values to variables in direct mode, or
by using constructions like \screentextwide{FOR} loops.  But we
haven't seen how we can get information from the user when a programme
is running.  One way that we can do this, is with the
\screentextwide{INPUT}\index{BASIC 65 Commands!INPUT}\index{INPUT}
command.

\needspace{4cm} % Dont allow following paragraph to separate from
                % following screenshot
\screentextwide{INPUT} is quite easy to use: We just have to say which
variable we would like the input to go into.  For example, to tell the
computer to ask for the user to provide something to put into the
variable \screentextwide{A\$}, we could use something like
\screentextwide{INPUT A\$}.  The only trick with the \stw{INPUT}
command is that it cannot be used in direct mode\index{Direct Mode}.
If you try it, the computer will tell you \stw{ILLEGAL DIRECT
  ERROR}\index{Errors!Illegal Direct}\index{Illegal Direct Error}.
Try it, and you should see something like the following

\screenshotwrap{images/illegal-direct-error}

\needspace{4cm}
This means that the \stw{INPUT} command can only be used as part of a
programme.  So we can instead do something like the following:

\begin{screenoutput}
1 INPUT A$
2 PRINT "YOU TYPED "; A$
RUN
\end{screenoutput}

\needspace{4cm}
What do you think that this will do?  The first line will ask the
computer for something to put into the variable \stw{A\$}, and the
second line will print the string \stw{"YOU TYPED"}, followed by
what the \stw{INPUT} command read from the user.  Let's try it out:

\screenshotwrap{images/input-example-1}

Did you expect that to happen? What is this question mark doing there?
The \stw{?} here is the computer's way of telling you that a
programme is waiting for some input from you.  This means that the
computer uses the same symbol, \stw{?}, to mean two different things:
If you type it as part of a programme or in direct mode, then it is a
short-cut for the \stw{PRINT} command. That's when you type it. But if
the computer shows it to you, it has this other meaning, that the
computer is waiting for you to type something in. There is also a
third way that the computer uses the \stw{?} character. Have you
noticed what it is?  It is to indicate the start of an error
message. For example, a Syntax Error is indicated by \stw{?SYNTAX
 ERROR}. When a character or something has different meanings in
different situations or contexts, we say that it its {\em context
  dependent}\index{context dependent}.

\needspace{4cm}
But returning to our example,  if we now type
something in, and press the \specialkey{RETURN} key to tell the
computer that you are done, the programme will continue, like this:

\screenshotwrap{images/input-example-2}

\needspace{4cm}
Of course, we didn't really know what to type in, because the programme
didn't give any hints to the user as to what the programmer wanted
them to do. So we should try to provide some instructions.  For
example, if we wanted the user to type their name, we could print a
message asking them to type their name, like this:

\begin{screenoutput}
  1 PRINT "WHAT IS YOUR NAME"
  2 INPUT A$
  3 PRINT "HELLO "; A$
\end{screenoutput}

\needspace{4cm}
Now if we run this programme, the user will get a clue as to what we
expect them to do, and the whole experience will make a lot more sense
for them:

\screenshotwrap{images/input-example-3}

When we run the programme, we first see the \stw{WHAT IS YOUR NAME} message
from line 1.  The computer doesn't print the double-quote symbols,
because they only told the computer that the piece of information
between them is a string.  The string itself is only the part in
between.

After this we see the \stw{?} character again and the blinking cursor
telling us that the computer is waiting for some input from us.  The
rest of the programmed is {\em blocked}\index{IO!blocking}\index{blocked} from continuing until it we type the
piece of information.  Once we type the piece of input, the computer
stores it into the variable \stw{A\$}, and can continue.  Thus when it
reaches line 3 of the programme, it has everything it needs, and
prints out both the \stw{HELLO} message, as well as the information
stored in the variable called \stw{A\$}.

Notice that the word \stw{LISTER} doesn't appear anywhere in the
programme.  It exists only in the variable.  This ability to process
information that is not part of a programme is one of the things that
makes computer programmes so powerful and able to be used for so many
purposes. All we have to do is to change the input, and we can get
different output.


\needspace{4cm}
For example, with our programme we run it again and again, and give it
different input each time, and the
programme will adapt its output to what we type. Pretty nifty, right?
Let's have the rest of the crew try it out:

\screenshotwrap{images/input-extra-ignored-1}

We can see that each time the programme prints out the message
customised with the input that you typed in\ldots Until we get to
\stw{RIMMER, BSC}. As always, Mr. Rimmer is causing trouble.  In this
case, he couldn't resist putting his Bronze Swimming Certificate
qualification on the end of his name.

We see that the computer has
given us a kind of error message, \stw{?EXTRA IGNORED}\index{Extra
  Ignored}\index{Errors!Extra Ignored}\index{Warnings!Extra Ignored}.
The error is not written in red, and doesn't have the word \stw{ERROR}
on the end.  This means that it is a warning, rather than an error.
Because it is only a warning, the programme continues.  But something
has happened: The computer has ignored Mr. Rimmer's \stw{BSC}, that
is, it has ignored the extra input.  This
is because the \stw{INPUT} command doesn't really read a whole line
of input. Rather, it reads {\em one piece of information}.  The
\stw{INPUT} command thinks that a piece of information ends at the end
of a line of input, or when it encounters a comma (\stw{,}) or colon
(\stw{:}) character.\index{, (comma)}\index{: (colon)}

\needspace{4cm}
If you want to include one of those symbols, you need to surround the
whole piece of information in double-quotes.  So, if Mr. Rimmer had
read this guide instead of obsessing over the Space Core Directives,
he would have known to type \stw{"RIMMER, BSC"} (complete with the
double-quotes), to have the programme
  run correctly.  It is important that the quotes go around the whole
  piece of information, as otherwise the computer will think that the
  first quote marks the start of a new piece of information.  We can
  see the difference it makes below:

  \screenshotwrap{images/input-quoting-1}

\needspace{1.5cm}
While this can all be a bit annoying at times, it has a purpose: The
\stw{INPUT} command can be used to read more than one piece of
information.  We do this by putting more than one variable after the
\stw{INPUT} command, each separated by a comma.  The \stw{INPUT}
command will then expect multiple pieces of information.  For example,
we could ask for someone's name and age, with a programme like this:

\begin{screenoutput}
  1 PRINT "WHAT IS YOUR NAME AND AGE"
  2 INPUT A$, A
  3 PRINT "HELLO "; A$
  4 PRINT "YOU ARE"; A; " YEARS OLD."
\end{screenoutput}

\needspace{4cm}
If we run this programme, we can provide the two pieces of information
on the one line when the computer presents us with the \stw{?} prompt,
for example \stw{LISTER, 3000000}. Note the comma that separates the
two pieces of information, \stw{LISTER} and \stw{3000000}.  It's also
worth noticing that we haven't put any thousands separators into the
number 3,000,000.  If we did, the computer would think we meant three
separate pieces of information, \stw{3}, \stw{000} and \stw{000},
which is not what we meant.  So let's see what it looks like when we
give \stw{LISTER, 3000000} as input to the programme:

  \screenshotwrap{images/input-multiple-1}

  In this case, the \stw{INPUT}\index{INPUT}
  \index{BASIC 65 Commands!INPUT} command reads the two pieces of
information, and places the first into the variable \stw{A\$}, and the second
into the variable \stw{A}. When the programme reaches line 3 it prints
\stw{HELLO} followed by the first piece of information.
Then when it gets to line 4, it prints the string \stw{YOU ARE},
followed by the contents of the variable \stw{A}, which is the number
3,000,000, and finally the string \stw{YEARS OLD}.

It's also possible to just give one piece of information at a time.
In that case, the \stw{INPUT} command will ask for the second piece
of information with a double question-mark prompt, i.e., \stw{??}.
Once it has the second piece of information.  (If we had more than
two variables on the \stw{INPUT} command, it will still present the
same \stw{??} prompt, rather than printing more and more
question-marks.)

\needspace{4cm}
So if we try this with our programme, we can see this \stw{?} and
\stw{??} prompts, and how the first piece of information ends up in
\stw{A\$} because it is the first variable in the \stw{INPUT}
command.
The second piece of information ends up in \stw{A} because \stw{A} is
the second variable after the \stw{INPUT} command. Here's how it
looks if we give this input to our programme:


\screenshotwrap{images/input-multiple-2}

Until now we have been asking the user to input information by using a
\stw{PRINT} command to display the message, and then an \stw{INPUT}
command to tell the computer which variables we would like to have
some information input into.  But, like with the \stw{PRINT} command,
this is something that happens often enough, that there is a shortcut
for it. It also has the advantage that it looks nicer when
running, and makes the programme a little shorter. The short cut is to
put the message to show after the \stw{INPUT} command, but before the
first variable.

We can change our programme to use this approach.  First, we can
change line 3 to include the prompt after the \stw{INPUT} command.  We
can do this one of two ways: First, we could just type in a new line
3. The computer will automatically replace the old line 3 with the new
one.

But, as we have mentioned a few times now, programmers are lazy
beasts, and so there is a short-cut: If you can see the line on the
screen that you want to change, you can use the cursor keys to
navigate to that line, edit it on the screen, and then press the
\specialkey{RETURN} key to tell the computer to accept the new version
of the line.\index{Programmes!editing}\index{Programmes!replacing
  lines}\index{Lines!editing}\index{Lines!replacing}

\needspace{4cm}
Either way, you
can check that the changes succeeded by typing the \stw{LIST} command
on any line of the screen that is blank.  This will show the revised
version of the programme.  For example:

\screenshotwrap{images/replacing-line-1}

\needspace{3cm}
We still have a little problem, though: Line 1 will print the message
\stw{WHAT IS YOUR NAME AND AGE}, and then Line 2 will print it again!
We only want the message to appear once. Thus we would like to change
line 1 so that it doesn't do this any more.  Because there is no other
command on line 1 that we want to keep, that line can just become
empty. So we can type in something like this:

\begin{screenoutput}
1
\end{screenoutput}

\needspace{4cm}
We can confirm that the contents of the line have been deleted by
running the \stw{LIST} command again, like this:

\screenshotwrap{images/deleting-line-1}

Did you notice something interesting? When we told the computer to
make line 1 of the programme empty, it deleted it completely!
That's because the computer thinks that an empty line is of no use.
It also makes sure that your programmes don't get all cluttered up
with empty lines if you make lots of changes to your programmes.

It is also possible to DELETE a range of lines. For example (but don't do this now), you could delete lines 3-4 with:

\begin{screenoutput}
  DELETE 3-4
\end{screenoutput}

You can read more about the DELETE command in the BASIC 65 Command Reference.

\needspace{4cm}
With that out the way, let's run our programme and see what happens.
As usual, just type in the \stw{RUN} command and hit the
\specialkey{RETURN} key.  You should see something like this:

\screenshotwrap{images/input-comma}

\needspace{2.5cm}
We can see our prompt of \stw{WHAT IS YOUR NAME AND AGE} there, but
now the cursor is appearing without any \stw{?} character. This is
because we put a comma (\stw{,}) after the message in the \stw{INPUT}
command.  To get the question mark, we have to instead put a
semi-colon (\stw{;}) after the message, like this:

\begin{screenoutput}
INPUT "WHAT IS YOU NAME AND AGE"; A$, A
\end{screenoutput}

\needspace{4cm}
Now if we run the programme, we should see what we are looking for:

\screenshotwrap{images/input-semicolon}

  \subsubsection{Exercises to try}

  {\bf 1. Can you make the programme ask someone for their name, and
    then for their favourite colour?}

  At the moment it asks for their name and age. Can you change the
  programme so that it reports on their favourite colour instead of
  their age?

  {\em Clue:} What type of information is age? Is it numeric or a
  string? Is it the same type of information as the name of a colour?

  {\bf 2. Can you write a programme that asks someone for their name,
    prints the hello message, and then asks for their age and prints
    out that response?}

  \needspace{2cm}
  At the moment, the programme expects both pieces of information at
  the same time. This means the programme can't print a message about
  the first message until after it has both pieces of information.
  Change the programme so that you can have an interaction like the
  following instead:

\begin{screenoutput}
WHAT IS YOUR NAME? DEEP THOUGHT
HELLO DEEP THOUGHT
WHAT IS THE ANSWER? 42
YOU SAID THE ANSWER IS 42
\end{screenoutput}

{\em Clue:} You will need more lines in your programme, so that you
can have more than one \stw{INPUT} and \stw{PRINT} command.

{\bf 3. Can you write a programme that asks several questions, and
  then prints out the list of answers given?}

\needspace{2cm}
Think of several questions you would like to be able to ask someone,
and then write a programme that asks them, and remembers the answers
and prints them out with an appropriate message. For example, running
your programme could look like this:

\begin{screenoutput}
  WHAT IS YOUR NAME? FRODO
  HOW OLD ARE YOU? 33
  WHAT IS YOUR FAVOURITE FOOD? EVERYTHING!
  THANK YOU FOR ANSWERING.
  YOUR NAME IS FRODO
  YOU ARE 33 YEARS OLD
  YOU FAVOURITE FOOD IS EVERYTHING!
\end{screenoutput}

{\em Clue:} You will need more lines in you programme, to have the
various \stw{INPUT} and \stw{PRINT} commands.

{\em Clue:} You will need to think carefully about which variable
names you will use.

\section{Making simple decisions}

In the previous section we have learnt how to input text and numeric
data, and how to display it.  However, the programmes have just
followed the lines of instruction in order, without any way to decide
what to do, based on what has been input.

In this section we will see how we can take simple decisions using the
\stw{IF}\index{IF}\index{BASIC 65 Commands!IF} and
\stw{THEN}\index{THEN}\index{BASIC 65 Commands!THEN} commands.
The \stw{IF} command checks if something is true or false, and if it
is true, causes the computer to execute the command the comes after
the \stw{THEN} command.

The way the computer decides whether something is true or false is
that it operates on the supplied information using one of several
symbols. These symbols are thus called {\em operators}.  Also, because
the compare two things, they depend on the relationship of the
things.  For this reason they are called {\em relational}
operators.\index{relational operators}\index{operators!relational}
They include the following:

\begin{itemize}
  \item Equals (\stw{=}). For example, \stw{3 = 3} would be true,
    while \stw{3 = 2} would be false.
  \item Less than (\stw{<}). For example, \stw{1 < 3} would be true,
    while both \stw{3 < 3} and \stw{1 < 3} would be false.
  \item Greater than (\stw{>}). For example, \stw{3 > 1} would be
    true, while both \stw{3 > 3} and \stw{1 > 3} would be false.
\end{itemize}

As it is common to want to consider when something might be equal or
greater than, or equal or less than, there are short cuts for
this. Similarly, if you wish to test if something is not equal to
something else, there is a relational operator for this, too:

\begin{itemize}
\item Unequal, which we normally say as {\em not equal}\index{not
  equal}\index{unequal}\index{<> (not equal to)}
  (\stw{<>}). This is different to the mathematical symbol for not
  equal, $\ne$, because the MEGA65's character set does not include a
  character that looks like that. So the programmers who created BASIC
  for the MEGA65 used the greater than and less than signs together
  to mean either less than or greater than, that is, not equal to.
  For example, \stw{1 <> 3} would be true,
    while \stw{3 <> 3} would be false.
  \item Less than or equal to (\stw{<=}). For example, \stw{1 < 3} and
    \stw{3 <= 3} would be true,
    while both \stw{4 < 3} would be false.
  \item Greater than or equal to (\stw{>=}). For example, \stw{3 >= 1}
    and \stw{3 >= 3} would be
    true, while both \stw{1 >= 3} would be false.
\end{itemize}

A good trick if you have trouble remembering which way the \stw(<) and \stw(>)
signs go, the side with more ends of lines is the one that needs to
have more. For example, the \stw(<) symbol has one point on the left, but
two ends of lines on the right hand side.  So for something to be true
with \stw(<), the number on the left side needs to be less than the number
on the right side.  This trick even works for the equals sign, \stw(=),
because it has the same number of ends on both sides, so you can
remember that the numbers on both sides need to be equal.  It also
works when you have two symbols together, like \stw(>=), it is true if
the condition is true for any of the symbols in it. So in this case
the \stw(>) symbol has more ends on the left than the right, so if the
number on the left is bigger than the number on the right, it will be
true. But also because the \stw(=) symbol has two ends on each side,
it will be true if the two numbers are the same.

\needspace{2cm}
Using these relational operators, we can write a line that will do
something, but only if something is true or false.  Let's try this
out, with a few examples:

\begin{screenoutput}
  IF -2 < 0 THEN PRINT "-2 IS A NEGATIVE NUMBER"
  IF 2 < 0 THEN PRINT "2 IS A NEGATIVE NUMBER"
  IF 0 < -2 THEN PRINT "-2 IS A POSITIVE NUMBER"
  IF 0 < 2 THEN PRINT "2 IS A POSITIVE NUMBER"
\end{screenoutput}

\needspace{4cm}
These commands work fine in direct mode, so you can just type them
directly into the computer to see what they will do.  This can be
handy for testing whether you have the logic correct when planning an
\stw{IF} -- \stw{THEN} command.  If you type in those commands, you
should see something like the following:

\screenshotwrap{images/if-then-less-than-examples}

We can see that only the \stw{PRINT} commands that followed an
\stw{IF} command that has a true value were executed. The rest
were silently ignored by the computer.  But we can of course include
these into a programme. So lets make a little programme that will ask
for two numbers, and say whether they are equal, or if one is greater
or less than the other.  Before you have a look at the programme, have
a think about how you might do it, and see if you can figure it out.
The clue I will give you, is that the \stw{IF} command also accepts the name of
a variables, not just numbers. So you can do something like \stw{IF A
  > B THEN PRINT "SOMETHING"}. The programme will be on the next page, to stop you peeking before you
have a think about it!

\pagebreak

Did you have a go?  There are lots of different ways it could be done,
but here is what I came up with:

\begin{screenoutput}
1 INPUT "WHAT IS THE FIRST NUMBER"; A
2 INPUT "WHAT IS THE SECOND NUMBER"; B
3 IF A = B THEN PRINT "THE NUMBERS ARE EQUAL"
4 IF A > B THEN PRINT "THE FIRST NUMBER IS BIGGER"
5 IF B > A THEN PRINT "THE SECOND NUMBER IS BIGGER"
\end{screenoutput}

We can then run the programme as often as we like, and the computer
can tell us which of the two numbers we give it is biggest, or if they
are equal:

\screenshotwrap{images/if-compare-variables-1}

Notice how in this programme, we didn't use fixed numbers in the
\stw{IF} command, but instead gave variable names instead.  This is
one of the very powerful things in computer programming, together
with being able to make decision based on data. By being able to refer
to data by name, regardless of its current value or how it got there,
lets the programmer create very flexible programmes.

Let's think about a bit of a more interesting example: a ``guess the
number'' game.\index{Guess the number}\index{Games!Guess the number}
For this, we need to have a number that someone has to guess, and then
we need to accept guesses, and indicate whether the guess was correct
or not. If the guess is incorrect, we should tell the user if the
correct number is higher or lower.

We have already learned most the ingredients to make such a program: We
can use \stw{LET} to set a variable to the secret number, \stw{INPUT}
to prompt the user for their guess, and then \stw{IF}, \stw{THEN} and
\stw{PRINT} to tell the user whether their guess was correct or not.
So let's make something. Again, if you like, stop and think and
experiment for a few minutes to see if you can make such a programme
yourself.

Here is how I have done it.  But don't worry if you have done it in a
quite different way: There are often many ways to write a programme to
perform a particular task.

\begin{screenoutput}
1 SN=23
2 PRINT "GUESS THE NUMBER BETWEEN 1 AND 100"
3 INPUT "WHAT IS YOUR GUESS"; G
4 IF G<SN THEN PRINT "MY NUMBER IS BIGGER"
5 IF G>SN THEN PRINT "MY NUMBER IS SMALLER"
6 IF G=SN THEN PRINT "CONGRATULATIONS! YOU GUESSED MY NUMBER!"
\end{screenoutput}

\needspace{4cm}
The first line puts our secret number into the variable \stw{SN}.
The second line prints a message telling the user what they are
supposed to do. The third line asks the user for their guess, and puts
it into the variable \stw{G}. The
fourth, fifth and sixth lines then check whether the guess is correct
or not, and if not, which message it should print. This is done by
using the \stw{IF} command and an appropriate relative operator to
make each decision.  This works well, to a point. For example:

\screenshotwrap{images/guess-number-1}

We can see that it prints the message, and it asks for a guess, and
responds appropriately. But if we want to guess again, we have to use
the \stw{RUN} command again for each extra guess. That's a bit poor
from the user's perspective. However that is unlikely to be a problem
for long, because the user can see the secret number in the listing on
the screen!

So we would like to fix these problems.  Let's start with hiding the
listing.  We previously mentioned that when the screen scrolls,
anything that was at the top of the screen disappears.  So we could
just make sure the screen scrolls enough, that any listing that was
visible is no longer visible. We could do this using \stw{PRINT} and a
\stw{FOR} loop.  The screen is 25 lines, so we could do something
like:

\begin{screenoutput}
FOR I = 1 to 25
PRINT
NEXT I
\end{screenoutput}

But there are better ways.  If you hold down the \specialkey{SHIFT}
key, and then press the \specialkey{CLR\\HOME} key, it clears the
screen.  This is much simpler and more convenient. But how can we do
something like that in our programme?  It turns out to be very simple:
You can type it while entering a string!  This is because the keyboard
works differently based on whether you are in {\em quote
  mode}\index{quote mode}.

Quote mode is just a fancy way of
describing what happens when you type a double-quote character into
the computer: Until you type another double-quote or press the
\specialkey{RETURN}.  You might remember we mentioned the problem of
funny symbols coming up when using the cursor keys.  I didn't want to
distract you at the time, but that is a symptom of being in quote mode:
In quote mode many special keys show a symbol that represents them,
rather than taking their normal action.  For example, if you press the
cursor left key while in quote mode, a \stw{} symbol appears. If you
press the cursor right key, a \stw{}, up \stw{}, down \stw{} and the
\specialkey{CLR\\HOME} a \stw{}, and if you are holding down
\specialkey{SHIFT} and press \specialkey{CLR\\HOME} a \stw{}.

\needspace{3cm}
So let's use this to make the second line clear the screen when it
prints the \stw{GUESS THE NUMBER BETWEEN 1 AND 100} message.  The
first time you try it is a bit confusing, but once you get the hang of
it, it is quite easy.  What we want in the end is a line that looks
like this:

\begin{tcolorbox}[colback=black,coltext=white]
\verbatimfont{\codefont}
\begin{verbatim}
2 PRINT "GUESS THE NUMBER BETWEEN 1 AND 100"
\end{verbatim}
\end{tcolorbox}

To do this, start by typing \stw{2 PRINT "}.  Then hold the
\specialkey{SHIFT} key down, and tap the \specialkey{CLR\\HOME} key.
Your line should now look like \stw{2 PRINT"}.  If so, you have
succeeded! You can now finish typing the line as normal.  When you
have done that, you can use the \stw{LIST} command as usual, to make
sure that you have successfully modified the programme.   You should
see your modified line with the \stw{} symbol in it.

\screenshotwrap{images/guess-number-2}

\needspace{2cm}
If you now run the programme by typing in \stw{RUN} and pressing the
\specialkey{RETURN} key as usual, the 2\textsuperscript{nd} line tells
the compute to clear the screen before printing the rest of the message, like this:

\screenshotwrap{images/guess-number-3}

This hides the listing from the user, so that they can't immediately see
what our secret number is.  We can type our guess in, just like before,
but just like before, after one guess, it returns to the \stw{READY.}
prompt.  We really would like people to be able to make more than one
guess, without needing to know that they need to run the programme
again.

\needspace{3cm}
There are a few ways we could do this. We already saw the \stw{FOR} --
\stw{NEXT} pattern. With that, we could make the programme give the
user a certain number of guesses.  If we followed the \stw{NEXT}
command with another programme line, we could even tell the user when
they have taken too many guesses.  So lets have a look at our
programme and see how we might do that.  Here is our current listing again:

\begin{screenoutput}
1 SN=23
2 PRINT "GUESS THE NUMBER BETWEEN 1 AND 100"
3 INPUT"WHAT IS YOUR GUESS"; G
4 IF G<SN THEN PRINT "MY NUMBER IS BIGGER"
5 IF G>SN THEN PRINT "MY NUMBER IS SMALLER"
6 IF G=SN THEN PRINT "CONGRATULATIONS! YOU GUESSED MY NUMBER!"
\end{screenoutput}

If we want the user to have multiple guesses, we need to have lines 2
through 6 run multiple times.  This makes our life a bit tricky,
because it means we need to insert a line between line 1 and 2. But
unless you are a mathemagican, there are no whole numbers between 1
and 2, and the MEGA65 doesn't understand line numbers like 1.5.

\needspace{4cm}
Fortunately, the MEGA65 has the
\stw{RENUMBER}\index{RENUMBER}\index{BASIC 65 Commands!RENUMBER}
\index{Lines!renumbering}
command.  This command can be typed only in direct mode. When
executed, it changes the line numbers in the programme, while keeping
them in the same order.  The new numbers are normally multiples of 10,
so that you have lots of spare numbers in between to add extra lines.
For example, if we use it on our programme, it will renumber the lines
to 10, 20, \ldots, 60. We can see that this has happened by using the
\stw{LIST} command:

\screenshotwrap{images/renumber-1}

\needspace{3cm}
Now our life is much easier: We can choose any  number that is between
10 and 20 to put our \stw{FOR} command into.  It's a common choice to
use the middle number, so that if you think of other things you want
to add in later, you have the space to do it.  So let's add a
\stw{FOR} command to give the user 10 chances to guess the number.  We
can use any variable name we like for this, except for \stw{G} and
\stw{SN}, because we are using those. It would be very confusing if we
mixed those up!  So lets add a line like this:

\begin{screenoutput}
15 FOR I = 1 TO 10 STEP 1
\end{screenoutput}

\needspace{3cm}
Now we need a matching \stw{NEXT I} after line 60.  Let's keep the
nice pattern of adding 10 to work out the next line number, and put it
as line 70:

\begin{screenoutput}
70 NEXT I
\end{screenoutput}

\needspace{4cm}
We can type those lines in, and then use \stw{LIST} command to make
sure the result is correct:

\screenshotwrap{images/guess-number-4}

That's looking pretty good.  But there are a couple of little problems still.
Can you work out what they might be? What will happen now after the user makes a guess?
What will happen if they run out of guesses?

If you worked out that making a guess that the screen will be
immediately cleared, you can give yourself a pat on the back! The user
will hardly have time to see the message. Worse, if they guess the
number correctly, they won't know, and the programme will keep going.
We'd really like the programme to stop or end, once the user makes a
correct guess.

\index{STOP}\index{BASIC 65 Commands!STOP}
\index{END}\index{BASIC 65 Commands!END}
\index{CONT}\index{BASIC 65 Commands!CONT}
We can do this using either the \stw{STOP} or
\stw{END} commands.  These two commands are quite similar.  The main
difference is that if you \stw{STOP} a programme, the computer tells
you where it has stopped, and you have the chance to continue the
programme using the \stw{CONT} command.  The \stw{END} command, on the
other hand, tells the computer that the programme has reached its end,
and it should go back to being \stw{READY}.  The \stw{END} command
makes more sense for our programme, because after the user has guessed
the number, there isn't any reason to continue.

Now we need a way to be able tell the computer to do two different
things when the user makes a correct guess. We could just add an extra
\stw{IF} command after line 60 which prints the congratulations
message, e.g., \stw{65 IF G=SN THEN END}.

But we can be a bit more
elegant than that: There is a way to have multiple commands on a
single line.  If you remember back to when we were learning about the
\stw{INPUT} command, you might remember that there were two different
characters that separate pieces of information: \stw{,} and\index{, (comma)}
\stw{:}\index{: (colon)}. The second one, \stw{:}, is called a colon, and can also be
used to separate BASIC commands on a single line.  So if we want to
change line 60 to \stw{PRINT} the message of congratulations and then
\stw{END} the programme, we can just add \stw{: END} to the end of the
line. The line should look like this:\index{: (colon)}

\begin{screenoutput}
  60 IF G=SN THEN PRINT "CONGRATULATIONS! YOU GUESSED MY NUMBER!": END
\end{screenoutput}

That solves that problem.  But it would also be nice to not clear the
screen after every guess, so that the user can see what their last
guess was, and whether it was bigger or smaller than the number.  To
do this, we can remove the clear-screen code from line 20, and add a
new print command to a lower line number, so that it clears the screen
once at the start of the programme, before the user gets to start
guessing.

\needspace{2cm}
For example, we could it put in line 5, so that it happens
as the absolute first action of the programme.  As we mentioned
earlier, the line numbers themselves aren't important: All that is
important is to remember that the computer starts at the lowest line
number, and runs the lines in order.  Anyway, let's make those changes
to our programme:

\begin{screenoutput}
  20 PRINT "GUESS THE NUMBER BETWEEN 1 AND 100"
  5 PRINT ""
\end{screenoutput}

\needspace{4cm}
If you type those lines in, and \stw{LIST} the programme again, you
should see something like the following:

\screenshotwrap{images/guess-number-5}

\needspace{4cm}
We can now \stw{RUN} the programme, and see whether it worked. Let's try it!

\screenshotwrap{images/guess-number-6}

The screen still clears, which is good.  Can you notice one little
difference already, though?  There is a blank line above the first
message. This is because our \stw{PRINT} command in line 5 goes to
the next row on the screen after it has printed the clear-screen character.  We can
fix this by putting a \stw{;} (semi-colon) character at the end of the
\stw{PRINT} command.  This tells the \stw{PRINT} command that it
shouldn't go to the start of the next row on the screen when it has
done everything.  So if we change line 5 to \stw{5 PRINT "";} this
will make the empty space at the top the screen disappear.

\needspace{4cm}
But back to our programme, we can now make guesses, and the programme
will tell us whether each guess is more or less than the correct
number.  And after 10 guesses, it stops asking for guesses, and goes
back to the \stw{READY.} prompt, like this:

\screenshotwrap{images/guess-number-7}

\needspace{2cm}
It would be nice to tell the user if they have run out of
guesses. We need to add this message after the \stw{NEXT} command.
We should also be nice and tell them what the secret number was,
instead of leaving them wondering.
So let's add the line to the end of our programme as line 80:

\begin{screenoutput}
80 PRINT "SORRY! YOU RAN OUT OF GUESSES. MY NUMBER WAS"; SN
\end{screenoutput}

\needspace{4cm}
Now if the user doesn't guess the number, they will get a useful
message, like this:

\screenshotwrap{images/guess-number-8}

\subsubsection{Exercises to try}

{\bf 1. Can you make the programme ask at the start for the secret number?}

At the moment the programme sets the secret number to 23 every
time. To make the game more interesting it would be great to ask the
first user for the secret number, and then start the rest of the game,
so that someone else can try to guess the number.

{\em Clue:} You will need change the line that sets the \stw{SN} variable
so that it can be read from the first user. You might find the
\stw{INPUT} statement useful.

{\bf 2. Can you make the programme ask for the user's name and give
  personalised responses?}

At the moment, the programme displays very simple messages. It would
be nice to ask the user their name, and then use their name to produce
personalised messages, like \stw{SORRY DAVE, BUT THAT NUMBER IS TOO
  SMALL}.

{\em Clue: You will need to add a line early in the programme to ask
  the user their name.}

{\em Clue: You might like to review how we used the \stw{PRINT}
  command, including with \stw{;} to print more than one thing on a line.}

{\bf 3. Can you improve the appearance of the messages with colours and better spacing?}

We haven't really made the programme particularly pretty.  It would be
great to use colours.

{\em Clue: You might like to add more \stw{PRINT} commands to improve
  the spacing and layout of the messages.}

{\em Clue: You might like to use either the colour codes
  in the messages you \stw{PRINT}}

{\em Clue: You might also like to use the \stw{FOREGROUND},
\stw{BACKGROUND} and \stw{BORDER} commands to set the colour of the
text, screen background and border.
\index{FOREGROUND}\index{BASIC 65 Commands!FOREGROUND}
\index{BACKGROUND}\index{BASIC 65 Commands!BACKGROUND}
\index{BORDER}\index{BASIC 65 Commands!BORDER}}


{\bf 4. Can you make the programme say if a guess is ``warmer'' or ``colder'' than the previous guess?}

At the moment the programme just tells you if the guess is higher or
lower than the secret number.  It would be great if it could tell you
if a guess is getting closer or further away with each guess: When
they get closer, it should tell the user that they are getting ``warmer'',
and ``colder'' when they get further away.

This is quite a bit more involved than the previous exercises, and
requires you to work out some new things.

{\em Clue: You will need to remember the previous guess in a different
  variable, and then compare it with the last one: Is it nearer or
  further away. You might need to have \stw{IF} commands that have
  another \stw{IF} after the first one, or to learn how to use the
  \stw{AND} operator.\index{AND}\index{BASIC 65 Operators!AND}}

\section{Random numbers and chance}

We'll come back to the Guess The Number game shortly, but let's take a
detour first. Through a maze. Let's hope we can get back out before
the end of the lesson!  Let's look at a simple way to make a
maze. This programme has been known for a long time.  It works by
choosing at random whether to display a {\symbolfont{M}} or a
{\symbolfont{N}} symbol.  These symbols are obtained by holding down
the \specialkey{SHIFT} key and tapping either the N or M keys.  You
can see the symbols on the front of those keys.  While they are shown
on the keys with a box around them, the box does not appear, only the
diagonal line.  It turns out that printing either of these two
characters at random draws a decent looking maze.

\needspace{4cm}
Let's give it a try.  To be able to do this, we need a way to generate
randomness.  The MEGA65 has the \stw{RND(1)} function to do this.  This
function works like a variable, but each time you try to use it, it
gives a different result.  Let's see how that works.  Type in the
following:\index{RND()}\index{BASIC 65 Functions!RND}

\begin{screenoutput}
PRINT RND(1)
\end{screenoutput}

Each time you type this, it will give a different answer, as you can
see here:

\screenshotwrap{images/rnd-1}

We can see that this gives us several different results: \stw{1.07870447E-03},
\stw{.793262171}, \stw{.44889513}, \stw{.697215893}.  Each of these is
a number between 0 and 1, even the first one.  The first one is
written in {\em scientific notation}\index{scientific notation}.  The
\stw{E-03} means that the value is $1.07870447\times10^{-3}$ =
0.000107870447.  That is, the \stw{E-03} means to move the decimal
place three places to the left. If there is a \stw{+} after \stw{E},
then it means to move the decimal place to the right. For example,
\stw{1.23456E+3} represents the number 1234.56.

\needspace{3cm}
Now, I promised a maze, so I better give you one. We can use this
\stw{RND(1)} to pick between these two symbols.  The first one has a
character code of 205, and the second one conveniently 206.  This
means that if we add the result of \stw{RND(1)} to 205.5, we will get
a number between 205.5 and 206.5.  Half the time it will be
$205.something$, and the other half of the time it will be $206.something$.
We can use this to print one or the other characters by using the
\stw{CHR\$()} function that returns the character corresponding to the
number we put between the brackets.  This means we can do something
like:

\begin{screenoutput}
  LET C = 205.5+RND(1)
  PRINT CHR$(C);
\end{screenoutput}

\needspace{3cm}
This will print one or the other of these symbols each time. We could
use this already to print the maze by doing this over and over, making
a loop. We could use \stw{FOR} and \stw{NEXT}. But in this case, we
want it to go forever, that is, each time the programme gets to the
end, we want it to go to the start again.  The people who created
BASIC really weren't very creative, so the command to do this is
called \stw{GOTO}\index{GOTO}\index{BASIC 65 Commands!GOTO}.  You put
the number of the line that you want to be executed next after it,
e.g., \stw{GOTO 1}.  We can use this to write our little maze
programme so that it will run continuously:

\begin{screenoutput}
10 LET C = 205.5+RND(1)
20 PRINT CHR$(C);
30 GOTO 10
\end{screenoutput}

\needspace{4cm}
If you \stw{RUN} this programme, it will start drawing a maze forever,
that looks like the screen shot below.  You can stop it at any time by
pressing the \specialkey{RUN\\STOP} key, or you can pause it by
pressing the \specialkey{NO\\SCROLL} key, and unpause it by pressing
the \specialkey{NO\\SCROLL} key again\index{NO SCROLL}. If you press
the \specialkey{RUN\\STOP} key, the computer will
tell you where it was up to at the time. In the case of the screenshot
below, it was working on line 10:

\screenshotwrap{images/rnd-2}

\needspace{2cm}
That works nicely, and draws a very famous maze \cite{montfort201210}.
We can, however, make the programme smaller.  We don't need to put the
result of the calculation of which symbol to display on a separate
line.  We can put the calculation directly into brackets for the
\stw{CHR\$()} function:

\begin{screenoutput}
10 PRINT CHR$(205.5+RND(1));
20 GOTO 10
\end{screenoutput}

\needspace{2cm}
And we can use what we learnt about the \stw{:} (colon) symbol, and
put the \stw{GOTO} command onto the same line as the \stw{PRINT}
command:

\begin{screenoutput}
10 PRINT CHR$(205.5+RND(1));: GOTO 10
\end{screenoutput}

Can you see how there are often many ways to get the same effect from
a programme? This is quite normal. For complex programmes, there are
many, many ways to get the same function.  This is one of the areas
in computer programming where you can be very creative.

But back to the topic of randomness. It's all well and good using
these random numbers between 0 and 1 for drawing a maze, but it's a
bit tricky to ask people to get a really long decimal.  If we want a
number in the range 1 to 100, we can multiply what we get from
\stw{RND(1)} by 100. If we do that, it gets a bit better, but we will
still get numbers like \stw{55.0304651}, \stw{30.3140154},
\stw{60.2505497} and \stw{.759229916}.

\needspace{3cm}
That's closer, but we really want to get rid of those fractional
parts. That is, we want whole numbers or {\em integers}.  BASIC has
the \stw{INT()} function that works like the \stw{RND(1)} function,
except that whatever number you put in the brackets, it will return
just the whole part of that.  So for example \stw{INT(2.18787)} will
return the value \stw{2}. As I said just now, it chops off the
fractional part, that is, it always rounds down. So even if we do
\stw{INT(2.9999999)} the result will still be \stw{2}, not \stw{3}.
This means that if we multiply the result of \stw{RND(1)} by 100, we
will get a number in the range of 0 -- 99, not 1 -- 100. This is nice
and easy to fix: We can just add 1 to the result.  So to generate an
integer, that is a whole number, that is between 1 and 100 inclusive,
we can do something like:

\begin{screenoutput}
  PRINT INT(RND(1)*100) + 1
\end{screenoutput}

\needspace{3cm}
That looks much better. So lets type in our ``guess the number''
programme again. But this time, lets replace the place where we set
our secret number to the number 23, to instead set it to a random
integer between 1 and 100.  Don't peek at the solution just yet. Have a
think about how we can use the above to set \stw{SN} to a random
integer between 1 and 100.  Once you have your guess ready, have a
look what I came up with below. You might have made a different
programme that can do the same job. That's quite fine, too!

\begin{screenoutput}
10 SN=INT(RND(1)*100)+1
20 PRINT ""
30 FOR I = 1 TO 10 STEP 1
40 PRINT "GUESS THE NUMBER BETWEEN 1 AND 100"
50 INPUT"WHAT IS YOUR GUESS"; G
60 IF G<SN THEN PRINT "MY NUMBER IS BIGGER"
70 IF G>SN THEN PRINT "MY NUMBER IS SMALLER"
80 IF G=SN THEN PRINT "CONGRATULATIONS! YOU GUESSED MY NUMBER!": END
90 NEXT I
100 PRINT "SORRY, YOU HAVE RUN OUT OF GUESSES"
\end{screenoutput}

Now we don't have to worry about someone guessing the number, and we
don't need someone else to pick the number for us. This makes the
programme much more fun to play.  Can you beat it?


\subsubsection{Exercises to try}

{\bf 1. Can you make the maze programme make different mazes?}

The maze programme currently displays equal numbers of {\symbolfont{N}}
and {\symbolfont{M}}. Can you change the programme to print twice as
many of one than the other?  How does the maze look then?

{em Clue: We used \stw{205.5} so that when we add a random number
  between 0 and 1, we end up with $205.something$ half the time and
  $206.something$ the other half of the the time.  If you reduce
  \stw{205.5} towards \stw{205}, or increase it towards \stw{206} you
  will change the relative proportion of each character that appears.

{\bf 2. Can you modify the ``guess my number'' programme to choose a
  number between 1 and 10?}

At the moment, the programme picks a number between 1 and 100.  Modify
the programme so that it picks a number from a different range. Don't
forget to update the message printed to the user.  Do they still need
10 guesses? Change the maximum number of guesses they get before
losing to a more suitable amount.

{\em Clue: You will need to modify the line that sets \stw{SN}, as
  well as the \stw{PRINT} message that gives instruction to the user.}

{\bf 3. Set the screen, border and text colour to random colours}

Modify either the maze or ``guess my number'' programme to use
random colours.  How might you make sure that the text is always
visible?

{\em Clue: Use the \stw{FOREGROUND}, \stw{BACKGROUND} and \stw{BORDER}
  commands to set the colours. Use colour numbers between 0 and 15,
  inclusive.
  You can put a calculation at the end of
  these commands in place of a simple number.}

{\em Clue: To make sure you don't set the text colour to the same as
  the background, you might like to calculate which background colour
  you wish to use and keep it in one variable, and then calculate the
  text colour to use and store it in a different variable. If the two
  variables have the same number, then you need to change one of
  them.}

{\bf 4. Make the ``guess my number'' programme randomly choose between
  two different greeting messages when it starts.}

The ``guess my number'' programme currently always prints the same
message every time it starts.  Modify it so that it prints one of two
possible messages each time.

{\em Clue: Use \stw{RND(1)} to obtain a random number. If that number
  is less than some threshold, print the first message, else print the
  second message.}

{\em Clue: It might be easier, if you store the random number in a
  variable, so that you can use two \stw{IF} statements to decide
  whether to print each message.}

{\em Clue: If you use \stw{<} (less than) as the relational operator
  in one of the \stw{IF} statements, you will need to use the opposite
  in the other one.  The opposite of less than is greater than or
  equal to.}
